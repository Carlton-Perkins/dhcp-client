use std::convert::TryInto;

use mac_address::MacAddress;

use crate::dhcp::traits::{Deserialize, Serialize};

pub type TransactionToken = [u8; 4];

#[derive(Eq, PartialEq, Debug)]
pub struct DhcpPacket {
    op: u8,
    htype: u8,
    hlen: u8,
    hops: u8,
    xid: [u8; 4],
    secs: [u8; 2],
    flags: [u8; 2],
    ciaddr: [u8; 4],
    yiaddr: [u8; 4],
    siaddr: [u8; 4],
    giaddr: [u8; 4],
    chaddr: [u8; 208],
    cookie: [u8; 4],
    options: Vec<DhcpOption>,
}

#[derive(Eq, PartialEq, Debug)]
pub struct DhcpOption {
    id: u8,
    body: Vec<u8>,
}

impl DhcpPacket {
    pub fn new() -> Self {
        DhcpPacket {
            op: 0x01,
            htype: 0x01,
            hlen: 0x06,
            hops: 0x00,
            xid: [0x00; 4],
            secs: [0x00; 2],
            flags: [0x80, 0x00],
            ciaddr: [0x00; 4],
            yiaddr: [0x00; 4],
            siaddr: [0x00; 4],
            giaddr: [0x00; 4],
            chaddr: [0x00; 208],
            cookie: [0x63, 0x82, 0x53, 0x63],
            options: vec![],
        }
    }

    pub fn with_transaction(mut self, token: &TransactionToken) -> Self {
        self.xid = *token;
        self
    }

    pub fn with_option(mut self, option: DhcpOption) -> Self {
        self.options.push(option);
        self
    }

    pub fn with_mac_address(mut self, maddr: &MacAddress) -> Self {
        self.chaddr = maddr
            .bytes()
            .iter()
            .chain([0; 202].iter())
            .cloned()
            .collect::<Vec<_>>()
            .try_into()
            .expect("Length of chaddr is unexpected");
        self
    }
}

impl Default for DhcpPacket {
    fn default() -> Self {
        Self::new()
    }
}
impl Serialize for DhcpPacket {
    type Out = Vec<u8>;
    fn serialize(&self) -> Self::Out {
        let mut buffer = Vec::new();

        buffer.extend_from_slice(&[self.op]);
        buffer.extend_from_slice(&[self.htype]);
        buffer.extend_from_slice(&[self.hlen]);
        buffer.extend_from_slice(&[self.hops]);
        buffer.extend_from_slice(&self.xid);
        buffer.extend_from_slice(&self.secs);
        buffer.extend_from_slice(&self.flags);
        buffer.extend_from_slice(&self.ciaddr);
        buffer.extend_from_slice(&self.yiaddr);
        buffer.extend_from_slice(&self.siaddr);
        buffer.extend_from_slice(&self.giaddr);
        buffer.extend_from_slice(&self.chaddr);
        buffer.extend_from_slice(&self.cookie);

        self.options
            .iter()
            .for_each(|x| buffer.extend_from_slice(&x.serialize()));
        // Options list needs to finish with the END option
        buffer.push(0xff);

        // Align buffer to 32 bytes
        let buffer_byte_len = buffer.len();
        (0..buffer_byte_len % 32).for_each(|_| buffer.push(0x00));

        buffer
    }
}

impl Deserialize for DhcpPacket {
    type Out = Self;
    fn deserialize(data: &[u8]) -> Option<Self::Out> {
        let op = data[0];
        let htype = data[1];
        let hlen = data[2];
        let hops = data[3];
        let xid = data[4..8].try_into().unwrap();
        let secs = data[8..10].try_into().unwrap();
        let flags = data[10..12].try_into().unwrap();
        let ciaddr = data[12..16].try_into().unwrap();
        let yiaddr = data[16..20].try_into().unwrap();
        let siaddr = data[20..24].try_into().unwrap();
        let giaddr = data[24..28].try_into().unwrap();
        let chaddr = data[28..236].try_into().unwrap();
        let cookie = data[236..240].try_into().unwrap();
        let options = DhcpOption::deserialize(&data[240..]).unwrap();

        // ! TODO add error handling for unwraps
        Some(DhcpPacket {
            op,
            htype,
            hlen,
            hops,
            xid,
            secs,
            flags,
            ciaddr,
            yiaddr,
            siaddr,
            giaddr,
            chaddr,
            cookie,
            options,
        })
    }
}

impl DhcpOption {
    pub fn new(id: u8, body: Vec<u8>) -> Self {
        DhcpOption { id, body }
    }
}

impl Serialize for DhcpOption {
    type Out = Vec<u8>;
    fn serialize(&self) -> Self::Out {
        let mut buffer = Vec::new();

        buffer.push(self.id);
        buffer.push(self.body.len().try_into().unwrap());
        buffer.extend_from_slice(&self.body);
        buffer
    }
}

impl Deserialize for DhcpOption {
    type Out = Vec<Self>;
    fn deserialize(data: &[u8]) -> Option<Self::Out> {
        let data = data.to_vec();
        let mut cursor = 0;
        let mut option_buffer = vec![];
        println!("option data {:?}", data);
        while cursor < data.len() {
            let id = data[cursor];
            if id == 255 {
                break;
            }
            let len = data[cursor + 1] as usize;
            println!("Id {}, Len {}", id, len);
            let body = &data[(cursor + 2)..((cursor + 2) + len)];

            option_buffer.push(DhcpOption {
                id,
                body: body.to_vec(),
            });
            cursor = cursor + 2 + len;
        }
        Some(option_buffer)
    }
}

#[cfg(test)]
mod dhcp_packet {
    use super::*;
    use pretty_assertions::assert_eq;

    #[test]
    fn test_serialize_option() {
        // Options should serialize to <type><length><body>
        // where length is the byte size of the body

        assert_eq!(
            DhcpOption {
                id: 53,
                body: vec![0x01]
            }
            .serialize(),
            vec![0x35, 0x01, 0x01]
        ); // Type message
        assert_eq!(
            DhcpOption {
                id: 61,
                body: vec![0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0]
            }
            .serialize(),
            vec![0x3d, 0x07, 0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0]
        ); // Client identifer
    }

    #[test]
    fn test_deserialize_option() {
        // Vec<u8> should deserialize to options

        assert_eq!(
            vec![DhcpOption {
                id: 53,
                body: vec![0x01]
            }],
            DhcpOption::deserialize(&[0x35, 0x01, 0x01]).unwrap()
        ); // Type message
        assert_eq!(
            vec![DhcpOption {
                id: 61,
                body: vec![0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0]
            }],
            DhcpOption::deserialize(&[0x3d, 0x07, 0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0])
                .unwrap(),
        ); // Client identifer
    }
    #[test]
    fn test_serialize_packet() {
        let test_packet = DhcpPacket {
            op: 1,
            htype: 1,
            hlen: 6,
            hops: 0,
            xid: [0x88, 0xa7, 0x38, 0x4d],
            secs: [0; 2],
            flags: [0x80, 0x00],
            ciaddr: [0; 4],
            yiaddr: [0; 4],
            siaddr: [0; 4],
            giaddr: [0; 4],
            chaddr: [
                0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            cookie: [0x63, 0x82, 0x53, 0x63],
            options: vec![
                DhcpOption::new(53, vec![1]),
                DhcpOption::new(50, vec![192, 168, 1, 99]),
                DhcpOption::new(55, vec![1, 3, 15, 6]),
            ],
        };
        assert_eq!(
            test_packet.serialize(),
            vec![
                0x01, 0x01, 0x06, 0x00, 0x88, 0xa7, 0x38, 0x4d, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
                0x53, 0x63, 0x35, 0x01, 0x01, 0x32, 0x04, 0xc0, 0xa8, 0x01, 0x63, 0x37, 0x04, 0x01,
                0x03, 0x0f, 0x06, 0xff
            ]
        )
    }

    #[test]
    fn test_deserialize_packet() {
        let packet = DhcpPacket::new();

        assert_eq!(
            DhcpPacket::deserialize(&packet.serialize()).unwrap(),
            packet
        );
    }

    #[test]
    fn test_deserialize_packet_real() {
        let test_packet = vec![
            0x01, 0x01, 0x06, 0x00, 0x88, 0xa7, 0x38, 0x4d, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
            0x53, 0x63, 0x35, 0x01, 0x01, 0x32, 0x04, 0xc0, 0xa8, 0x01, 0x63, 0x37, 0x04, 0x01,
            0x03, 0x0f, 0x06, 0xff,
        ];
        let expected_test_packet = DhcpPacket {
            op: 1,
            htype: 1,
            hlen: 6,
            hops: 0,
            xid: [0x88, 0xa7, 0x38, 0x4d],
            secs: [0; 2],
            flags: [0x80, 0x00],
            ciaddr: [0; 4],
            yiaddr: [0; 4],
            siaddr: [0; 4],
            giaddr: [0; 4],
            chaddr: [
                0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            cookie: [0x63, 0x82, 0x53, 0x63],
            options: vec![
                DhcpOption::new(53, vec![1]),
                DhcpOption::new(50, vec![192, 168, 1, 99]),
                DhcpOption::new(55, vec![1, 3, 15, 6]),
            ],
        };

        let generated_packet = DhcpPacket::deserialize(&test_packet).unwrap();

        assert_eq!(generated_packet, expected_test_packet);
    }
}
