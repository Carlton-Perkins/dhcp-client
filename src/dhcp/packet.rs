use crate::dhcp::traits::{Deserialize, Serialize};
use mac_address::MacAddress;
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;
use std::{convert::TryInto, net::Ipv4Addr, time::Duration};

pub type TransactionToken = [u8; 4];

#[derive(Copy, Clone, Eq, PartialEq, FromPrimitive)]
pub enum DhcpMessageType {
    Discover = 1,
    Offer = 2,
    Request = 3,
    Ack = 5,
    Nak = 6,
}

#[derive(Copy, Clone, Eq, PartialEq)]
pub enum DhcpOptionType {
    SubnetMask = 1,
    RouterIp = 3,
    DnsServerIp = 6,
    HostName = 12,
    RequestedIp = 50,
    LeaseTime = 51,
    MessageType = 53,
    DhcpServerIp = 54,
    ParameterRequest = 55,
    ClientId = 61,
    End = 255,
}

#[derive(Eq, PartialEq, Debug)]
pub struct DhcpPacket {
    op: u8,
    htype: u8,
    hlen: u8,
    hops: u8,
    xid: [u8; 4],
    secs: [u8; 2],
    flags: [u8; 2],
    ciaddr: [u8; 4],
    yiaddr: [u8; 4],
    siaddr: [u8; 4],
    giaddr: [u8; 4],
    chaddr: [u8; 208],
    cookie: [u8; 4],
    options: Vec<DhcpOption>,
}

#[derive(Eq, PartialEq, Debug)]
pub struct DhcpOption {
    id: u8,
    body: Vec<u8>,
}

impl DhcpPacket {
    pub fn new() -> Self {
        DhcpPacket {
            op: 0x01,
            htype: 0x01,
            hlen: 0x06,
            hops: 0x00,
            xid: [0x00; 4],
            secs: [0x00; 2],
            flags: [0x80, 0x00],
            ciaddr: [0x00; 4],
            yiaddr: [0x00; 4],
            siaddr: [0x00; 4],
            giaddr: [0x00; 4],
            chaddr: [0x00; 208],
            cookie: [0x63, 0x82, 0x53, 0x63],
            options: vec![],
        }
    }

    pub fn with_transaction(mut self, token: &TransactionToken) -> Self {
        self.xid = *token;
        self
    }

    pub fn with_option(mut self, option: DhcpOption) -> Self {
        self.options.push(option);
        self
    }

    pub fn with_mac_address(mut self, maddr: &MacAddress) -> Self {
        self.chaddr = maddr
            .bytes()
            .iter()
            .chain([0; 202].iter())
            .cloned()
            .collect::<Vec<_>>()
            .try_into()
            .expect("Length of chaddr is unexpected");
        self
    }

    pub fn is_type(&self, mtype: DhcpMessageType) -> bool {
        match self.get_type() {
            Some(t) => mtype == t,
            None => false,
        }
    }

    pub fn get_type(&self) -> Option<DhcpMessageType> {
        let body = self.get_option_body(DhcpOptionType::MessageType);
        match body {
            Some(b) => FromPrimitive::from_u8(b[0]),
            None => None,
        }
    }

    pub fn is_transaction(&self, token: &TransactionToken) -> bool {
        *token == self.xid
    }

    pub fn get_client_ip(&self) -> Ipv4Addr {
        Ipv4Addr::from(self.yiaddr)
    }

    pub fn get_lease_time(&self) -> Option<Duration> {
        let body = self.get_option_body(DhcpOptionType::LeaseTime);
        match body {
            Some(b) => Some(Duration::from_secs(
                u32::from_be_bytes(b.try_into().unwrap()) as u64, // assume BigEndian, should be safe on the net
            )),
            None => None,
        }
    }

    pub fn get_server_ip(&self) -> Option<Ipv4Addr> {
        let body = self.get_option_body(DhcpOptionType::DhcpServerIp);
        Self::get_option_ip_like(body)
    }

    pub fn get_subnet(&self) -> Option<Ipv4Addr> {
        let body = self.get_option_body(DhcpOptionType::SubnetMask);
        Self::get_option_ip_like(body)
    }

    pub fn get_router_ip(&self) -> Option<Ipv4Addr> {
        let body = self.get_option_body(DhcpOptionType::RouterIp);
        Self::get_option_ip_like(body)
    }

    fn get_option_body(&self, otype: DhcpOptionType) -> Option<&[u8]> {
        let body = self.options.iter().find(|x| x.id == otype as u8);
        match body {
            Some(b) => Some(&b.body),
            None => None,
        }
    }

    fn get_option_ip_like(body: Option<&[u8]>) -> Option<Ipv4Addr> {
        match body {
            Some(b) => Some(Ipv4Addr::from(u32::from_be_bytes(b.try_into().unwrap()))), // assume BigEndian, should be safe on the net
            None => None,
        }
    }
}

impl Default for DhcpPacket {
    fn default() -> Self {
        Self::new()
    }
}
impl Serialize for DhcpPacket {
    type Out = Vec<u8>;
    fn serialize(&self) -> Self::Out {
        let mut buffer = Vec::new();

        buffer.extend_from_slice(&[self.op]);
        buffer.extend_from_slice(&[self.htype]);
        buffer.extend_from_slice(&[self.hlen]);
        buffer.extend_from_slice(&[self.hops]);
        buffer.extend_from_slice(&self.xid);
        buffer.extend_from_slice(&self.secs);
        buffer.extend_from_slice(&self.flags);
        buffer.extend_from_slice(&self.ciaddr);
        buffer.extend_from_slice(&self.yiaddr);
        buffer.extend_from_slice(&self.siaddr);
        buffer.extend_from_slice(&self.giaddr);
        buffer.extend_from_slice(&self.chaddr);
        buffer.extend_from_slice(&self.cookie);

        self.options
            .iter()
            .for_each(|x| buffer.extend_from_slice(&x.serialize()));
        // Options list needs to finish with the END option
        buffer.push(DhcpOptionType::End as u8);

        // Align buffer to 32 bytes
        let buffer_byte_len = buffer.len();
        (0..buffer_byte_len % 32).for_each(|_| buffer.push(0x00));

        buffer
    }
}

impl Deserialize for DhcpPacket {
    type Out = Self;
    fn deserialize(data: &[u8]) -> Option<Self::Out> {
        // All of these try intos are to make unsized &[u8] into fixed sized [u8, n]
        // failure will only be possible if changing the data structure of DhcpPacket
        let op = data[0];
        let htype = data[1];
        let hlen = data[2];
        let hops = data[3];
        let xid = data[4..8].try_into().unwrap();
        let secs = data[8..10].try_into().unwrap();
        let flags = data[10..12].try_into().unwrap();
        let ciaddr = data[12..16].try_into().unwrap();
        let yiaddr = data[16..20].try_into().unwrap();
        let siaddr = data[20..24].try_into().unwrap();
        let giaddr = data[24..28].try_into().unwrap();
        let chaddr = data[28..236].try_into().unwrap();
        let cookie = data[236..240].try_into().unwrap();
        let options = DhcpOption::deserialize(&data[240..]).unwrap();

        Some(DhcpPacket {
            op,
            htype,
            hlen,
            hops,
            xid,
            secs,
            flags,
            ciaddr,
            yiaddr,
            siaddr,
            giaddr,
            chaddr,
            cookie,
            options,
        })
    }
}

impl DhcpOption {
    pub fn new(id: u8, body: Vec<u8>) -> Self {
        DhcpOption { id, body }
    }
}

impl Serialize for DhcpOption {
    type Out = Vec<u8>;
    fn serialize(&self) -> Self::Out {
        let mut buffer = Vec::new();

        buffer.extend_from_slice(&[self.id]);
        buffer.extend_from_slice(&[self.body.len().try_into().unwrap()]);
        buffer.extend_from_slice(&self.body);
        buffer
    }
}

impl Deserialize for DhcpOption {
    type Out = Vec<Self>;
    fn deserialize(data: &[u8]) -> Option<Self::Out> {
        let data = data.to_vec();
        let mut cursor = 0;
        let mut option_buffer = vec![];
        while cursor < data.len() {
            let id = data[cursor];
            if id == DhcpOptionType::End as u8 {
                break;
            }
            let len = data[cursor + 1] as usize;
            let body = &data[(cursor + 2)..((cursor + 2) + len)];

            option_buffer.push(DhcpOption {
                id,
                body: body.to_vec(),
            });
            cursor = cursor + 2 + len;
        }
        Some(option_buffer)
    }
}

#[cfg(test)]
mod dhcp_packet {
    use super::*;
    use pretty_assertions::assert_eq;
    use rand::random;

    #[test]
    fn test_serialize_option() {
        // Options should serialize to <type><length><body>
        // where length is the byte size of the body

        assert_eq!(
            DhcpOption {
                id: 53,
                body: vec![0x01]
            }
            .serialize(),
            vec![0x35, 0x01, 0x01]
        ); // Type message
        assert_eq!(
            DhcpOption {
                id: 61,
                body: vec![0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0]
            }
            .serialize(),
            vec![0x3d, 0x07, 0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0]
        ); // Client identifer
    }

    #[test]
    fn test_deserialize_option() {
        // Vec<u8> should deserialize to options

        assert_eq!(
            vec![DhcpOption {
                id: 53,
                body: vec![0x01]
            }],
            DhcpOption::deserialize(&[0x35, 0x01, 0x01]).unwrap()
        ); // Type message
        assert_eq!(
            vec![DhcpOption {
                id: 61,
                body: vec![0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0]
            }],
            DhcpOption::deserialize(&[0x3d, 0x07, 0x01, 0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0])
                .unwrap(),
        ); // Client identifer
    }
    #[test]
    fn test_serialize_packet() {
        let test_packet = DhcpPacket {
            op: 1,
            htype: 1,
            hlen: 6,
            hops: 0,
            xid: [0x88, 0xa7, 0x38, 0x4d],
            secs: [0; 2],
            flags: [0x80, 0x00],
            ciaddr: [0; 4],
            yiaddr: [0; 4],
            siaddr: [0; 4],
            giaddr: [0; 4],
            chaddr: [
                0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            cookie: [0x63, 0x82, 0x53, 0x63],
            options: vec![
                DhcpOption::new(53, vec![1]),
                DhcpOption::new(50, vec![192, 168, 1, 99]),
                DhcpOption::new(55, vec![1, 3, 15, 6]),
            ],
        };
        assert_eq!(
            test_packet.serialize(),
            vec![
                0x01, 0x01, 0x06, 0x00, 0x88, 0xa7, 0x38, 0x4d, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
                0x53, 0x63, 0x35, 0x01, 0x01, 0x32, 0x04, 0xc0, 0xa8, 0x01, 0x63, 0x37, 0x04, 0x01,
                0x03, 0x0f, 0x06, 0xff
            ]
        )
    }

    #[test]
    fn test_deserialize_packet() {
        let packet = DhcpPacket::new();

        assert_eq!(
            DhcpPacket::deserialize(&packet.serialize()).unwrap(),
            packet
        );
    }

    #[test]
    fn test_deserialize_packet_real() {
        let test_packet = vec![
            0x01, 0x01, 0x06, 0x00, 0x88, 0xa7, 0x38, 0x4d, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x63, 0x82,
            0x53, 0x63, 0x35, 0x01, 0x01, 0x32, 0x04, 0xc0, 0xa8, 0x01, 0x63, 0x37, 0x04, 0x01,
            0x03, 0x0f, 0x06, 0xff,
        ];
        let expected_test_packet = DhcpPacket {
            op: 1,
            htype: 1,
            hlen: 6,
            hops: 0,
            xid: [0x88, 0xa7, 0x38, 0x4d],
            secs: [0; 2],
            flags: [0x80, 0x00],
            ciaddr: [0; 4],
            yiaddr: [0; 4],
            siaddr: [0; 4],
            giaddr: [0; 4],
            chaddr: [
                0x10, 0x7b, 0x44, 0x93, 0xe6, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ],
            cookie: [0x63, 0x82, 0x53, 0x63],
            options: vec![
                DhcpOption::new(53, vec![1]),
                DhcpOption::new(50, vec![192, 168, 1, 99]),
                DhcpOption::new(55, vec![1, 3, 15, 6]),
            ],
        };

        let generated_packet = DhcpPacket::deserialize(&test_packet).unwrap();

        assert_eq!(generated_packet, expected_test_packet);
    }

    #[test]
    fn test_random_packet_serialization() {
        let test_count = 10000;

        for _ in 0..test_count {
            let random_packet = DhcpPacket {
                op: random(),
                htype: random(),
                hlen: random(),
                hops: random(),
                xid: random(),
                secs: random(),
                flags: random(),
                ciaddr: random(),
                yiaddr: random(),
                siaddr: random(),
                giaddr: random(),
                chaddr: [0; 208], // Random cant generated arrays this big, so skip this for now
                cookie: random(),
                options: vec![], // TODO Need a good way to generate valid options
            };

            let serialized_packet = random_packet.serialize();
            let deserialized_packet = DhcpPacket::deserialize(&serialized_packet).unwrap();

            assert_eq!(random_packet, deserialized_packet);
        }
    }

    #[test]
    fn test_packet_is_type() {
        let packet_a = DhcpPacket::new().with_option(DhcpOption::new(53, vec![1]));
        let packet_b = DhcpPacket::new().with_option(DhcpOption::new(53, vec![2]));

        assert!(packet_a.is_type(DhcpMessageType::Discover));
        assert!(!packet_a.is_type(DhcpMessageType::Offer));
        assert!(packet_b.is_type(DhcpMessageType::Offer));
        assert!(!packet_b.is_type(DhcpMessageType::Discover));
    }

    #[test]
    fn test_packet_is_transaction() {
        let token_a: TransactionToken = random();
        let token_b: TransactionToken = random();
        let packet_a = DhcpPacket::new().with_transaction(&token_a);
        let packet_b = DhcpPacket::new().with_transaction(&token_b);

        assert!(packet_a.is_transaction(&token_a));
        assert!(!packet_a.is_transaction(&token_b));
        assert!(packet_b.is_transaction(&token_b));
        assert!(!packet_b.is_transaction(&token_a));
    }
}
